---
description: "Standards for professional tooling: PDF generation, AI document refinement, architecture diagrams, and documentation orchestration."
globs:
  - "tools/**/*"
alwaysApply: true
tags:
  - tools
  - documentation
  - python
version: "v1.0.0"
lastUpdated: "2025-11-19"
---

## Tools Directory Overview

This directory contains production-ready tooling for enterprise documentation workflows. All tools follow SOLID principles and are designed for reusability, extensibility, and integration.

### Tool Categories

1. **`pdf/`** - Markdown → PDF/DOCX Generation Pipeline
   - Playwright-based rendering for pixel-perfect PDFs
   - Mermaid diagram pre-rendering with theme optimization
   - Adaptive pagination with intelligent diagram scaling
   - Document profiles for branding (cover pages, headers, footers)
   - Layout analysis and transformation

2. **`prompts/`** - AI Agent-Based Document Refinement
   - SOLID multi-agent system (Structure Analyzer, Content Enhancer, Technical Reviewer, Style Polisher)
   - Support for OpenAI (GPT-4) and Anthropic (Claude)
   - YAML-based pipeline configuration
   - Automated gap analysis, content enhancement, technical validation

3. **`structurizr/`** - Architecture Diagram Generation
   - Docker-based Structurizr CLI wrapper
   - Batch export to multiple formats (Mermaid, PNG, SVG)
   - SOLID refactored with clean interfaces

4. **`docs_pipeline/`** - Documentation Orchestrator
   - Coordinates diagram generation + document rendering
   - YAML-based configuration
   - Batch processing for multiple documents

## Architectural Principles for Tools

### SOLID Compliance

All tools must follow SOLID principles:

- **Single Responsibility**: Each module/class has one focused purpose
- **Open/Closed**: Easy to extend without modifying existing code
- **Liskov Substitution**: Interfaces are properly abstracted
- **Interface Segregation**: Clean, focused interfaces (no fat interfaces)
- **Dependency Inversion**: Depend on abstractions, not concretions

### Code Organization

```
tool-name/
├── core/                    # Interfaces, models, exceptions
│   ├── interfaces.py        # Abstract interfaces (IExecutor, IAgent, etc.)
│   ├── models.py            # Data models (dataclasses, configs)
│   └── exceptions.py        # Custom exceptions
├── implementations/         # Concrete implementations
├── cli.py                   # Command-line interface
├── README.md                # Usage guide
├── ARCHITECTURE.md          # Design documentation
└── requirements.txt         # Dependencies
```

### Documentation Standards

Every tool must have:

1. **README.md** - Usage guide with examples
2. **ARCHITECTURE.md** (for complex tools) - Design decisions, patterns, extensibility
3. **QUICKSTART.md** (optional) - Get started in 5 minutes
4. **Docstrings** - All public classes and methods
5. **Type hints** - Throughout the codebase

### Testing Standards

- Unit tests for core logic
- Integration tests for end-to-end workflows
- Example configurations and test data
- Automated test suites (where applicable)

## Python Standards for Tools

### Code Style

- **PEP 8** compliance
- **Type hints** on all function signatures
- **Docstrings** in Google or NumPy style
- **Async/await** for I/O-bound operations
- **Dataclasses** for configuration and models

### Error Handling

```python
# Define custom exceptions
class ToolError(Exception):
    """Base exception for tool errors"""
    pass

class ConfigurationError(ToolError):
    """Raised when configuration is invalid"""
    pass

# Use specific exceptions
def load_config(path: Path) -> Config:
    if not path.exists():
        raise ConfigurationError(f"Config not found: {path}")
    # ...
```

### Configuration

- **YAML** for user-facing configuration
- **Dataclasses** for internal configuration models
- **Validation** at load time (fail fast)
- **Defaults** for optional settings

### Logging

```python
import logging

logger = logging.getLogger(__name__)

# Use structured logging
logger.info("Processing document", extra={
    "document": doc_name,
    "agent": agent_name,
    "duration_ms": duration
})
```

## Integration Patterns

### Tool Composition

Tools should be composable:

```bash
# Individual tools
python -m tools.prompts.cli rough.md polished.md -c config.yaml
python tools/pdf/md2pdf.py polished.md --profile reporting-manager

# Orchestrated workflow
python -m tools.docs_pipeline.cli --config docs-pipeline.yaml
```

### Configuration Sharing

- Use consistent YAML structure across tools
- Support environment variable overrides
- Allow CLI arguments to override config files

### Output Management

- Default output to `C:\documentpipeline` (Windows) or `~/documentpipeline` (Linux/macOS)
- Create directories automatically
- Use descriptive naming schemes
- Support custom output paths via CLI

## Quality Checklist

Before committing tool changes:

- [ ] **SOLID principles** followed
- [ ] **Type hints** on all public functions
- [ ] **Docstrings** on all public classes/methods
- [ ] **Error handling** with specific exceptions
- [ ] **Tests** added or updated
- [ ] **Documentation** updated (README, ARCHITECTURE)
- [ ] **Examples** work and are tested
- [ ] **CLI** has helpful messages and examples
- [ ] **Dependencies** documented in requirements.txt

## Tool-Specific Guidelines

### PDF Generation (`tools/pdf/`)

- **Playwright** for rendering (not WeasyPrint for new features)
- **Mermaid** diagrams pre-rendered to SVG
- **Adaptive layout** with intelligent scaling
- **Document profiles** for branding
- **Layout policies** for tunable rules

### AI Agents (`tools/prompts/`)

- **Agent pattern** with `IDocumentAgent` interface
- **Prompt templates** in `library/` directory
- **Pipeline configs** in `pipelines/` directory
- **Mock executor** for testing without API calls
- **Temperature control** per agent (analytical vs creative)

### Architecture Diagrams (`tools/structurizr/`)

- **Docker-based** execution (no local Structurizr install)
- **Batch export** to multiple formats
- **Clean interfaces** (`IContainerExecutor`, `IWorkspaceExporter`)
- **Error handling** for Docker failures

## Future Enhancements

Consider these patterns for new tools:

- **Plugin architecture** for extensibility
- **Event-driven** workflows with callbacks
- **Streaming** for real-time feedback
- **Caching** for expensive operations
- **Parallel processing** for batch operations
- **Web UI** for non-technical users
- **API endpoints** for programmatic access

## References

- Root Cursor rules: `/.cursor/index.mdc`
- Python standards: `/.cursor/python-microservices.mdc`
- Documentation standards: `/.cursor/documentation.mdc`
- Testing standards: `/.cursor/testing.mdc`
