"""
Image path correction step - Fixes broken image references after Pandoc conversion.

Problem: DiagramRenderingStep embeds SVG content directly in markdown.
When Pandoc converts to HTML, relative paths can become broken.

Solution: After Pandoc generates HTML, verify and fix all image src attributes
to point to correct file locations.

This step runs AFTER PandocConversionStep (Step 6).
"""

import re
from pathlib import Path
from typing import List, Tuple
from ..base import PipelineStep, PipelineContext, PipelineError


class ImagePathCorrectionStep(PipelineStep):
    """
    Correct relative image paths in HTML after Pandoc conversion.
    
    Order of execution: AFTER PandocConversionStep
    
    Issues fixed:
    1. SVG files generated by DiagramRenderingStep have correct names
    2. Pandoc may alter relative paths
    3. Browser needs correct path from HTML location to SVG files
    
    Processing:
    1. Load generated HTML
    2. Find all <img src=...> tags
    3. Verify SVG files exist in work_dir
    4. Fix paths to be relative to HTML file location
    5. Handle cases where paths are embedded data URIs (skip)
    6. Write corrected HTML back
    """
    
    def get_name(self) -> str:
        return "Image Path Correction"
    
    def validate(self, context: PipelineContext) -> None:
        """Ensure HTML file exists"""
        if not context.html_file:
            raise PipelineError("HTML file not generated yet")
    
    def execute(self, context: PipelineContext) -> bool:
        """
        Fix image paths in HTML to correctly reference SVG diagrams.
        """
        
        try:
            html_file = context.html_file
            
            if not html_file.exists():
                self.log(f"HTML file not found: {html_file}", context)
                return True  # Non-critical
            
            # Read HTML
            html_content = html_file.read_text(encoding='utf-8')
            
            # Find all SVG files in work_dir
            svg_files = list(context.work_dir.glob("diagram_*.svg"))
            
            if not svg_files:
                self.log("No SVG diagram files found, skipping path correction", context)
                return True
            
            self.log(f"Correcting paths for {len(svg_files)} SVG files", context)
            
            # Fix image src paths
            corrections_made = 0
            html_content, corrections_made = self._fix_image_paths(
                html_content, svg_files, html_file, context
            )
            
            if corrections_made > 0:
                # Write corrected HTML
                html_file.write_text(html_content, encoding='utf-8')
                self.log(f"✓ Corrected {corrections_made} image path(s)", context)
            else:
                self.log("No image paths needed correction", context)
            
            return True
        
        except Exception as e:
            self.log(f"ERROR: Path correction failed: {e}", context)
            return True  # Non-critical, continue without correction
    
    def _fix_image_paths(self, html_content: str, svg_files: List[Path], 
                        html_file: Path, context: PipelineContext) -> Tuple[str, int]:
        """
        Fix all <img src=...> tags in HTML to correctly reference SVG files.
        
        Returns:
            (corrected_html, number_of_corrections)
        """
        
        corrections = 0
        
        # Pattern to find img tags: <img src="..." ...>
        img_pattern = r'<img\s+([^>]*?)src=["\']([^"\']*)["\'']([^>]*)>'
        
        def replace_img_src(match):
            nonlocal corrections
            before_src = match.group(1)
            src_path = match.group(2)
            after_src = match.group(3)
            
            # Skip data URIs (inline images)
            if src_path.startswith('data:'):
                return match.group(0)  # Keep as-is
            
            # Skip absolute URLs
            if src_path.startswith(('http://', 'https://', '/')):
                return match.group(0)  # Keep as-is
            
            # Try to find matching SVG file
            correct_path = self._find_correct_svg_path(src_path, svg_files, html_file, context)
            
            if correct_path:
                # Construct corrected img tag
                corrected = f'<img {before_src}src="{correct_path}"{after_src}>'
                corrections += 1
                
                if context.get_config('verbose'):
                    self.log(f"  Fixed: {src_path} → {correct_path}", context)
                
                return corrected
            
            return match.group(0)  # Keep original if we can't find file
        
        # Replace all img src attributes
        corrected_html = re.sub(img_pattern, replace_img_src, html_content, flags=re.IGNORECASE)
        
        return corrected_html, corrections
    
    def _find_correct_svg_path(self, referenced_path: str, svg_files: List[Path],
                              html_file: Path, context: PipelineContext) -> str:
        """
        Find the correct SVG file and return relative path from HTML location.
        
        This handles several cases:
        1. referenced_path is just filename (diagram.svg) → find matching diagram_NNN.svg
        2. referenced_path includes wrong directory → strip and find correct file
        3. referenced_path is relative path that's broken → fix it
        
        Returns:
            Relative path from HTML to SVG, or empty string if not found
        """
        
        ref_name = Path(referenced_path).name.lower()
        
        # Try exact match first
        for svg_file in svg_files:
            if svg_file.name.lower() == ref_name:
                # Calculate relative path from HTML to SVG
                return self._get_relative_path(html_file, svg_file)
        
        # Try matching by base name (without number)
        # E.g., "diagram.svg" matches "diagram_001.svg"
        if ref_name.startswith('diagram'):
            for svg_file in svg_files:
                if svg_file.name.startswith('diagram'):
                    # Return path to first matching diagram
                    return self._get_relative_path(html_file, svg_file)
        
        # No match found
        return ""
    
    def _get_relative_path(self, from_file: Path, to_file: Path) -> str:
        """
        Calculate relative path from one file to another.
        
        Example:
        from_file: /work/output.html
        to_file: /work/diagram_001.svg
        returns: "diagram_001.svg"
        
        Example with different dirs:
        from_file: /work/output.html
        to_file: /diagrams/diagram_001.svg
        returns: "../diagrams/diagram_001.svg"
        """
        
        try:
            # If both files are in same directory, just use filename
            if from_file.parent == to_file.parent:
                return to_file.name
            
            # Use relative_to with proper path calculation
            rel_path = to_file.relative_to(from_file.parent)
            return str(rel_path).replace('\\', '/')  # Normalize path separators
        
        except ValueError:
            # Files are in different drive/mount, use absolute path
            # (This shouldn't happen in normal pipeline, but safe fallback)
            return str(to_file).replace('\\', '/')
